## 基础

### 事务特征 ACID

- 原子性：一个事务必须被视为一个不可分割的最小工作单元
- 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态
- 隔离性：一个事务所做的修改在最终提交以前，对其他事物是不可见的。（通常来说。需要考虑事务的隔离级别）
- 持久性：一旦事务提交，所做的修改会永久保存到数据库中

### 隔离级别

|                  | 问题                                                         |                                                        |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| READ UNCOMMITTED | 可以读取未提交的数据                                         | 很少使用                                               |
| READ COMMITTED   | 两次同样的查询，可能结果不一样                               |                                                        |
| REPEATABLE READ  | 幻读：另一个事务插入了新的记录，产生幻行                     | 默认事务级别。InnoDB和XtraDB通过MVCC解决了幻读的问题。 |
| SERIALIZABLE     | 强制事务串行执行。会在读取的每一行数据加锁，产生大量的超时和锁征用问题 | 很少使用                                               |

### 死锁

- 死锁条件
  - 互斥条件
  - 占有且等待
  - 循环等待
  - 不可剥夺
- 数据库系统：死锁检测和死锁超时机制
  - InnoDB：**将持有最少行级排他锁**的事务进行**回滚**



### 多版本并发控制 MVCC

- MySQL的**事务型存储引擎**实现的都不是简单的行级锁。
  - 实现了**非阻塞的读操作**，写操作也**只锁定必要的行**

- InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。
  - 行创建时间
  - 行删除时间
- 不是实际时间值，而是系统版本号
  - 系统版本号：每开启一个新的事务，系统版本号都会自动递增
  - 事务版本号：事务开启时的系统版本号。

|        | REPEATABLE READ隔离级别下，MVCC具体操作                      |
| ------ | ------------------------------------------------------------ |
| SELECT | 行版本早于当前事务版本；删除标识未定义或大于当前事务版本号   |
| INSERT | 行版本号 = 当前系统版本号                                    |
| DELETE | 删除标识 = 当前系统版本号                                    |
| UPDATE | 新插入一条记录，行版本号 = 当前系统版本号；原来的行，删除标识 = 当前系统版本号 |

- MVCC 只在两个隔离界别下操作
  - READ UNCOMITTED 总是读取最新的数据行
  - SERIALIZABLE会对所有读取的行加锁



### InnoDb概览

- 使用MVCC来支持高并发
- 默认级别是REPEATABLE READ,通过**间隙锁**策略防止幻读的出现：**不仅仅锁定查询中的行，还会对索引中的间隙进行锁定**
- 基于**聚簇索引**。主键查询性能很高，非主键索引（二级索引）中必须包含主键列。故主键列应尽可能的小。





## 基准测试

### 测试指标

- 吞吐量：单位时间的事务处理数
- 响应时间或者延迟
- 并发性
  - WEB服务器并发性！=数据库并发性
  - 工作中的线程数
- 可扩展性







### 三大范式

**确保每列保持原子性**

**确保表中的每列都和主键相关**

**每列都和主键列直接相关,而不是间接相关**



### 范式和反范式

|              | 范式 | 反范式                 |
| ------------ | ---- | ---------------------- |
| 占用空间     | 小   |                        |
| 更新速度     | 快   |                        |
| 重复数据     | 少   |                        |
| 是否需要关联 |      | 否                     |
| 查询         |      | 避免无索引时的全表扫描 |





## 索引

### 索引基础

- MySQL中，索引是在**存储引擎**而不是服务器层实现的。

### B-Tree索引

- 限制：最左匹配原则
  - 如果不是按索引最左列开始查找，则无法使用索引
  - 不能跳过索引中的列
  - 如果查询中有范围查询，则右边所有列都无法使用索引优化





### 哈希索引

- 对所有的索引计算一个哈希码，同时在哈希表中保存指向每个数据的指针
- Memory引擎显示支持
  - 也支持非唯一哈希索引
- 缺点
  - **不支持排序**，不是按索引值顺序存储的
  - 不支持部分索引列匹配
  - 只支持等值比较查询
- 场合
  - “星型”schema
- 自适应哈希
  - InnoDB检测到某些索引值被使用得特别频繁时，会自动基于B-Tree索引再创建一个哈希索引





### 聚簇索引

数据行实际存放在**叶子节点**中，节点页只包含了索引列

- InnDB默认在主键上建立聚簇索引
  - 若没有定义主键
    - 先尝试在唯一、非空索引代替
    - 若没有，隐式地定义一个主键作为聚簇索引
- 二级索引叶子节点**包含了引用行的主键列**
  - 如果没有覆盖索引，那么就需要两次索引查找
- 覆盖索引
  - 一个索引覆盖所有需要查询的字段的值
  - **无需回表**



### 压缩索引 or  前缀索引

- 做法
  - 完全保存索引块中第一个值
  - 其他行：【相同前缀数，不同后缀部分】

- 优点：占用空间小
- 缺点：扫描需要随机查找。不适合CPU密集型





## 慢查询优化

### 基础：优化数据访问

- 确认**应用程序**是否在**检索**大量超过需要的数据
  - 查询不需要的记录
  - 多表关联时返回全部列
  - 总是取出全部列
- 确认**MySQL服务器层**是否在**分析大量超过需要的应用行**
  - 衡量标准
    - 响应时间
    - 扫描的行数
    - 返回的行数
  - 访问类型：type
    - ref：使用索引了
    - all：全表扫描
  - 优化方式
    - 索引覆盖扫描
    - 改变表结构，使用单独的汇总表
    - 重写查询

### 重构查询方式

- 切分查询：将大查询切换为小查询
  - 减少锁和阻塞
- 分解关联查询
  - 缓存效率更高
  - 减少锁的竞争
  - 在应用层做关联，更容易对数据库进行拆分



## 高级特性

### 外键约束

- 成本
  - 访问额外的表
  - 需要额外的锁，可能导致死锁
- 替代（当外键只是作为约束时）
  - 触发器替代外键
  - 应用程序里实现该约束















## 负载均衡：读写分离

### 如何实现

- 基于主从复制框架
  - 一个主库（MYSQL也不支持多主库），多个从库
  - 写主库，读从库



### 复制

1. 库将变更写入binlog日志
1. 从库开一个IO线程将主库binlog日志拷贝到自己的relay日志中
2. 从库有一个SQL线程会从中级日志读取binlog然后执行，保证数据一致性

![image-20200819114514202](https://raw.githubusercontent.com/YN-Zheng/img/master/typora202008/27/204222-480741.png)

### 延时问题

- 从库**串行化**同步数据，高并发环境下，从库数据一定更慢
- 解决方案
  - MYSQL的**并行复制**：从库开启多个线程，并行读取relaylog中不同库的日志，然后并行重放不同库的日志
  - 主库分库

### 

- 解耦，允许两个过程异步执行。**IO线程**能够独立于**SQL线程**之外工作



## 面试

### Myisam和InnoDB的区别

|          | Myisam     | InnoDB                           |
| -------- | ---------- | -------------------------------- |
| 锁       | 表级锁     | 支持行级锁，通过MVCC来支持高并发 |
| 索引     | 非聚簇索引 | 聚簇索引                         |
| 事务     | 不支持     | 支持                             |
| 外键     | 不支持     | 支持                             |
| 适用场景 | 多读少写   |                                  |



### 回表和覆盖索引

聚簇索引时，一次查询中需要被查询的字段没有被二级索引给覆盖到，需要再次通过聚簇索引获取所有字段的过程。

覆盖索引是指，索引中的字段已经覆盖了所有需要查询的字段，不需要回表。

而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。



### 那ACID靠什么保证的呢？

A原子性由**undo log日志**保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

C一致性一般由代码层面来保证

I隔离性由MVCC来保证

D持久性由内存+**redo log**来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复



### 幻读是怎么解决的？

MVCC叫多版本并发控制，实际上就是保存了数据在某个时间节点的快照。每行数据额外隐藏了两列：create_version和delete_version。每开启一个新的事务，版本号就会自动递增。MVCC的原理是查找**创建版本小于或等于当前事务版本，删除版本为空或者大于当前事务版本**。

MVCC解决了“不可重复读”的问题，但是无法解决幻读问题，即读到了其他事务后来插入的数据。

幻读可以通过MVCC+**间隙锁**解决。间隙锁是在可重复度级别下才有的锁，会自动锁定附近的行。

### 你们数据量级多大？分库分表怎么做的？

首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。

**垂直分库**

基于现在微服务拆分来说，都是已经做到了垂直分库了



![img](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53e22e5e5411435aa51f8456a496192b~tplv-k3u1fbpfcp-zoom-1.image)



**垂直分表**

如果表字段比较多，将不常用的、数据较大的等等做拆分



![img](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4e1a7ecbca240f78ea331a75bf109f2~tplv-k3u1fbpfcp-zoom-1.image)



**水平分表**

首先根据业务场景来决定使用什么字段作为分表字段(sharding_key)，比如我们现在日订单1000万，我们大部分的场景来源于C端，我们可以用user_id作为sharding_key，数据查询支持到最近3个月的订单，超过3个月的做归档处理，那么3个月的数据量就是9亿，可以分1024张表，那么每张表的数据大概就在100万左右。

比如用户id为100，那我们都经过hash(100)，然后对1024取模，就可以落到对应的表上了。

### 分表后的ID怎么保证唯一性的呢？

因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：

1. 设定步长，比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。
2. 分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种
3. 分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。

### 11. 分表后非sharding_key的查询怎么处理呢？

1. 可以做一个mapping表，比如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查询到用户列表，再通过user_id去查询。
2. 打宽表，一般而言，商户端对数据实时性要求并不是很高，比如查询订单列表，可以把订单表同步到离线（实时）数仓，再基于数仓去做成一张宽表，再基于其他如es提供查询服务。
3. 数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方式来做。或者异步的形式也是可以的。




### 说说mysql主从同步怎么做的吧？

首先先了解mysql主从同步的原理

1. master提交完事务后，写入binlog
2. slave连接到master，获取binlog
3. master创建dump线程，推送binglog到slave
4. slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中
5. slave再开启一个sql线程读取relay log事件并在slave执行，完成同步
6. slave记录自己的binglog



![img](https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ebf69bcb3594b679629f6231f00ea16~tplv-k3u1fbpfcp-zoom-1.image)



由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。

**全同步复制**

主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

**半同步复制**

和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。



