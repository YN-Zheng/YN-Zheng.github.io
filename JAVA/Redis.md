## 缓存

### 缓存类型

- 本地缓存
  - 容量小，无法扩展
  - JVM堆中的LRUMap
- 分布式缓存
  - 水平扩展能力
  - 需要进行远程请求
- 多级缓存
  - 本地缓存：只保存访问评率最高的部分热点数据
  - 分布式缓存：其他数据



### 淘汰策略

- FIFO：淘汰最早数据
- LRU：提出最近最少使用



### 

### Memcache和Redis

|                | Memcache     | Redis                                                        |
| -------------- | ------------ | ------------------------------------------------------------ |
| 处理模式       | 多线程异步IO | 单线程（非阻塞的异步事件处理机制）；内存IO时间短，避免线程上下文切换 |
| 是否支持持久化 | N            | Y                                                            |
| 数据结构       | 只支持K-V    | 多种                                                         |
| 主从同步？     | N            | Y                                                            |
|                |              |                                                              |



### 持久化

两种持久化方式

- RDB（镜像全量持久化）：将内存中的数据集以快照形式写入磁盘
  - 实际操作是通过fork子进程执行RDB操作
  - Copy on write： 子进程创建后，父子进程共享数据段；父进程继续提供读写服务。
  - 将整个Redis的数据保存在单一文件中，适合用来做灾备
- AOF（增量持久化）：以文本日志形式记录Redis处理的每一个写入或删除操作
  - 对日志文件的写入操作使用的追加模式，有灵活的同步策略



### **缓存雪崩、击穿、穿透**

- 穿透：使用不存在的用户id频繁请求接口，导致查询缓存始终不命中，大量请求穿透缓存访问到了DB
- 击穿：某个热点数据失效时，大量针对这个数据的请求会穿透到数据源
  - 随机退避方式，失效时随机sleep一个很短的时间
  - 针对多个热点key同时失效的问题，可以在缓存时的过期时间上加上一个小的随机数
- 雪崩：缓存挂掉，所有请求都会穿透到DB
  - 快速失败的熔断策略，减少DB瞬间压力
  - 使用主从模式和集群模式来尽量保存缓存服务的高可用



### 分布式数据库与缓存双写一致性方案

1. **先更新数据库，再更新缓存；（不好）**
   1. 线程安全问题：脏数据
   2. 业务场景：频繁更新缓存（数据还没到数据库）

1. **先删除缓存，再更新数据库；**
   1. 数据不一致问题
      - 先淘汰缓存
      - 再写数据库
      - 休眠一秒，再次淘汰缓存，将1秒内的缓存脏数据再次删除
2. **先更新数据库，再删除缓存。**



![image-20200819170413889](https://raw.githubusercontent.com/YN-Zheng/img/master/typora202008/27/205343-410537.png)





## 数据类型

### String

最常用的类型

- 共享用户Session

```bash
set key val
get key -- val
```



### Hashes

类似map的一种结构，可以将结构化的数据（如一个对象（**没嵌套其他对象**））

```bash
hset person name bingo
hset person age 20
hset person id 1
```

### Lists

有序列表

- 应用
  - 粉丝列表、文章的评论列表
  - 然后利用lrange命令实现分页查询

```bash
lpush mylist 1
lpush mylist 2 3 4

rpop mylist

# 0开始位置，-1结束位置，结束位置为-1时，表示列表的最后一个位置，即查看所有。
lrange mylist 0 -1
```



### Sets

- 无序集合，自动去重。
- 交集、并集、差集

```bash
sadd myset 1 # 添加元素
smembers myset # 查看全部元素 
sismember myset # 判断是否包含某个值

srem myset 1 2 3 # 删除某些元素

scard myset  # 查看元素个数
spop myset # 随即删除一个元素

smove yourset myset 2 # 将一个set的元素移动到另外一个set
sinter yourset myset # 求交集
sunion yourset myset # 求并集

sdiff yourset myset # 求在yourset中而不再myset中的元素
```



### Sorted Sets

排序的set，去重但排序，写进去的时候给一个分数

```bash
zadd board 85 yongnian
zadd board 72 lisi
zadd board 33 zheng

# 获取排名前三的用户
zrevrange board 0 3
# 获取某用户的排名
zrank board yongnian
```





## 布隆过滤器

### 原理

当一个元素被加入集合时

1. 通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。(bitmap)
2. 检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。



### 缺点

- 存在误报
- 删除困难



### 场景

缓存穿透

海量数据去重





