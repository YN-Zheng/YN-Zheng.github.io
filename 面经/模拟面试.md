*  目录
{:toc #markdown-toc}


## 秒杀项目

### 简要介绍一下项目吧

项目主要模拟了电商中常见的秒杀场景，目标是在高并发场景下，保证安全性能并且尽量优化系统的QPS。

首先用spring boot开发出系统框架，实现基本的登陆验证，商品页，秒杀等功能。然后再对系统进行一步步优化。主要的优化思路是减少数据库的访问。细节包括：

- 页面级优化
  - 页面静态化，前后端分离（利用浏览器缓存）
  - 对象缓存（商品、用户）
  - CDN优化
- 接口优化：减少数据库访问
  - Redis预减库存
  - 消息队列异步下单

安全性

- 明文密码两次md5处理
- JSR303参数校验+全局异常处理器
- 地址隐藏
- 接口防刷



### Redis聊聊

#### 数据结构有几种你知道吗

知道的。和Memcache相比，Redis的一大优势就在于其丰富的数据结构。

基本的数据结构有5种：

1. 字符串：最常用。比如我们可以将用户对象转化为JSON字符串进行缓存。
2. 字典hash：可以结构化的保存对象(但里面不能再嵌套对象)
3. 集合：共同好友。
4. 有序集合：排行榜、热搜榜等。
5. 列表：Redis使用双向链表实现的队列。可以用于用户文章分页展示、异步消息队列等。

高级的有

1. Bitmap：位图，可以用来实现布隆滤博器
2. Pipeline：批量执行一组数据

#### 你知道Redis为什么这么快吗

相比Memcache，Redis有以下特点：

1. 完全基于内存，绝大部分请求是纯粹的内存操作
2. 丰富的数据结构
3. 单线程。想使用到多核也可以启动**多实例**
4. 使用多路I/O复用模型，非阻塞IO



#### 你知道Redis分布式锁吗

Redis可以通过**原子性**操作SETNX来标记一个独占资源:

```bash
SETNX key value # 如果key不存在，则设置并赋值(原子性)
EXPIRE key seconds # 设置key的过期时间
# PX:过期时间
SET key value [EX seconds][PX milliseconds] [NX|XX]
```

Java代码演示:

```java
long status = redisService.setnx(key,"1");
if(status == 1){      /*** 若执行到这一行,机器挂掉,则永远不会释放锁 ***/
	redisService.expire(key, expire);
	//...执行独占资源逻辑
}
```



#### 持久化？

Redis提供了两种持久化方式：AOF和RDB

1. RDB将整个Redis的数据，以快照形式，保存在单一文件中。实际操作是通过fork出一个子线程来创建RDB文件，不阻塞服务器进程（**Copy-on-Write思想**）；采用二进制压缩存储。
2. AOF记录下除了查询以外的所有变更数据库状态的**指令**，并且以append的形式**追加保存**到AOF文件中（增量）。支持每秒同步。

由以上可知，RDB和AOF各有优缺点。RDB文件小，恢复快，但是无法保存快照间隙的数据；而AOF可读性高，适合保存增量数据，但是文件体积大，恢复慢。所以，REDIS4.0推出了目前的默认持久化方式：

3. RDB-AOF混合持久化方式



### 消息队列说一下吧

好的。我这个项目里面的消息队列主要是用来处理秒杀时大量的下单请求，起到**削峰填谷**的作用。

在一般的线上环境中。消息队列也可以起到**异步解耦**的作用。比如一个复杂的电商系统中，用户下单后，涉及到的服务除了生成订单，可能还有其他服务，比如短信通知，增加用户积分等等。随着业务不断扩展，请求链路会越来越长。如果串行执行的话，响应时间会很长。

而使用消息队列，只需要将下单成功的消息**异步**地发送给其他系统，减少了响应时间。同时，减少了系统间的耦合度。

消息队列作为一个中间件，还是增加了系统的复杂度的，也会有一定的缺点，包括：

1. 重复消息
2. 消息丢失
3. 消息的消费顺序等

同时，在分布式系统中也要考虑数据一致性的问题：分布式事务。

#### 重复消息

一条消息可能有多个监听服务。为了保证接口的**幂等性**，每个监听服务只能执行一次。但假如其中一个服务执行失败，它会要求消息发送方再发送一次，导致其他服务收到两次服务。所以我们需要考虑对每条消息进行校验。

1. 数据库
2. Redis：id+场景唯一标识

#### 消息丢失

![image-20200827203916204](https://raw.githubusercontent.com/YN-Zheng/img/master/typora202008/27/203917-92043.png)

如图，一共有三个阶段：

1. 生产消息：等待Broker的相应
2. 存储消息：保证消息刷盘后在给生产者反馈，
3. 消费消息：保证消息真正执行完业务逻辑后，再发送给Broker保证消费成功

#### 分布式事务

消息队列中间件在分布式事务中也有作用

1. 两段式提交：通过消息中间件协调多个系统。在系统开始事务时锁定资源但不提交，等两者都准备好了，告诉消息中间件，再提交
2. 半消息（最终一致性）
   1. 业务主动方本地事务提交失败，业务被动方不会收到消息的投递。
   2. 只要业务主动方本地事务执行成功，那么消息服务一定会投递消息给下游的业务被动方，并最终保证业务被动方一定能成功消费该消息（消费成功或失败，即最终一定会有一个最终态）。



## Spring自研框架

### 简单介绍一下项目吧

好的。首先这个项目它只依赖了Servelet，日志，cglib和Aspectj这几个库，实现了Spring core的基本功能。譬如说，你可以像使用Spring一样，把Bean交给容器管理。你也可以以面向切片的方式统一修饰方法。类似的，也可以利用RequestMapping或者ResponseBody等注解来映射或者返回一个JSON数据。 

总之，它实现了Spring core的核心功能：IOC和AOP，并且支持基本的MVC操作。当然，相比真正的Spring框架，还是相当简陋的。缺点有：

1. 只支持单例，所以不会有循环依赖的问题。
2. 只支持注解标记



### 说说你是怎么实现IOC、AOP、MVC的？

#### Ioc

好的。我是定义了一个HashMap作为容器，key是类型，value是对应的实例。

在容器初始化的时候，递归地扫描需要配置的目录下的每个类，如果类带有特定注解（如Service，Controller等），就将它们实例化并放入容器中。

容器初始化后，就可以依赖注入了，也就是将容器中的实例赋到被标有@Autowired的FIELD中。这样就基本实现了Spring 的IOC功能。

#### AOP

容器是OOP的高级工具，以低耦合、低侵入的方式打通从上到下的开发通道，但是无法很好地处理分散在业务里的通用系统请求（水平方向），譬如日志记录、系统权限校验等等。

在实现AOP之前，我们需要先选择代理方式。JDK动态代理和CGLIB都是动态代理，即可以在运行时动态地生成代理对象。不同的是，CGLIB不需要对象实现某个接口，而是会生成对象的子类，保证了对代码的最低侵入性。所以在Spring的最初版本中，AOP是借由CGLIB实现的。

然而，此时的SPRING AOP只支持对被某个标签标记的类进行横切逻辑的织入。为了减小切入点的粒度，需要引入AspectJ的表达式解析功能。

在容器初始化之后，依赖注入之前，获取每个方法被修饰的Aspect的列表，然后按照优先级的顺序依次加入他们在方法执行前、执行后的逻辑，生成代理对象，并将代理对象代替容器中的原始对象，最后再进行依赖注入。

具体来说，首先实现一个MethodInterceptor的实现类，用于CGLIB动态拦截生成对象。同时为了方便起见，定义一个抽象类作为供外接使用的横切逻辑骨架，在其中设置before，after等钩子方法。每个切面类都要继承这个抽象类并实现期望的钩子方法。在动态代理时，按优先级在invoke原始方法前或后依次调用这些切面的方法就可以了。



#### MVC

DispatcherServlet

- 解析请求路径和请求方法
- 依赖容器,建立并维护Controller方法与请求的映射
- 用合适的Controller方法去处理特定的请求

![image-20200822171739031](https://raw.githubusercontent.com/YN-Zheng/img/master/typora202008/27/204011-500142.png)

## JVM

### 说一说JVM的内存结构吧

Java虚拟机在执行Java程序的时候会将它所管理的内存划分为若干个不同的数据区域。不同的区域有各自的责任和生命周期。有的区域随虚拟机进程的启动一直存在，有的则是依赖用户线程的启动和结束而建立和销毁。因此也可以依据是否线程隔离来将它们分类。

线程隔离的区域有：程序计数器、虚拟机栈、本地方法栈。

1. 程序计数器可以看做是当前线程所执行的字节码的行号计数器，它是程序控制流的指示器。分支、循环、跳转、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行的是本地方法，则这个计数器值应当为空。同时，此内存区域还是唯一一个没有任何OutOfMemoryError情况的区域。
2. 虚拟机栈描述的是JAVA方法执行的内存模型：每个方法被执行的时候，JVM都会同步创建一个栈帧来存储**局部变量表、操作数栈、动态链接、方法出口**等信息。局部变量表存放了编译期间可知的各种Java虚拟机基本数据类型、对象引用和returnAddress类型。这个内存区域有两类异常状况：StackOverflowError或OutOfMemoryError。
3. 本地方法栈与虚拟机栈的作用非常相似，区别在于本地方法栈为虚拟机使用到的本地方法服务。

线程共享的区域有：堆、方法区

1. Java堆在虚拟机启动时创建，此内存区域唯一的目的就是存放对象实例，同时也是垃圾收集器管理的内存区域。在G1收集器出现以前，HotSpot虚拟机内部的垃圾收集器全部都是基于“经典分代”来设计，即堆可分为新生代和老年代，新生代又可以分为eden区和两个Survivor区。但是现在也产生了不采用分代设计的新垃圾收集器，所以分代设计也不是觉得的了。如果从分配内存的角度来看，Java堆还可以划分出多个线程私有的分配缓冲区（TLAB），以提升对象分配时的效率
2. 方法区用于存储已被虚拟机加载的类型信息、常量、静态变量等数据。运行时常量池也是方法区的一部分。

> Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中（一般也包括由符号引用翻译出来的直接引用）。
>
> 运行时常量池相对于Class文件常量池的另外一个重要特性是具备动态性。Java语言不要求常量一定只有编译期才能产生，运行期间也可以将新的常量放入池中。相关使用较多的是String类的intern()方法。

3. 直接内存



### 说一说对象创建过程吧

当Java虚拟机遇到一条字节码new指令时，

1. 首先去检查能否在常量池中定位到一个类的符号引用，若没有，先执行相应的类加载过程。
2. 通过类加载检查后，虚拟机将为新生对象分配内存（对象所需内存的大小在类加载完成后便可确定）。除了内存分配外，另一个需要考虑的是对象创建带来的线程安全问题。一种方案是对分配内存的动作进行同步处理（虚拟机实际上是采用CAS保证原子性），另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）*【LongAdder的思想】*

> 指针碰撞：假设Java堆中内存是绝对规整的，使用一个指针区分开被分配的空间和空闲空间。
>
> 空闲列表：Java堆中的内存并不是规整的，虚拟机必须维护一个列表，记录上哪些内存时可用的。
>
> 选择哪种方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理**的能力决定。如，Serial、ParNew等收集器支持，CSM不支持。

3. 内存分配完成后，虚拟机将分配到的内存空间都初始化为零值。（不包括对象头）
4. 接下来，JVM需要对对象进行必要的设置，包括：对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码（实际上需要调用Object::hashCode()方法才计算），这些信息存放在对象头中。根据对象锁状态的不同，对象头也会有不同的设置方式。

>对象头部分包括两类信息。第一类（Mark Word）适用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程池有的锁、偏向线程ID、偏向时间戳等。另一部分是类型指针，即对象指向它的类型元数据的指针。*【Synchronized的锁升级】*

5. 执行对象的构造函数。





### JVM是怎么通过引用去访问到堆中的对象的？

通过栈上的reference数据来操作堆上的具体对象。主流的访问方式由使用句柄和直接指针两种。

- 句柄访问：Java堆中划分出一块内存来作为句柄池，reference存储对象的句柄地址，而句柄中包含了对象实例数据与类型数据格子的地址信息
- 直接指针：reference直接存储的就是对象地址，对象的内存中则包含了访问数据类型的相关信息。

HotSpot主要使用直接指针方式进行对象访问。



### 类文件结构

### 类加载过程



虚拟机的类加载机制是指：JVM把描述类的Class文件加载至内存，对数据进行校验、准备、解析、初始化，最终形成可以被虚拟机直接使用的Java类型。类加载在Java中是在运行期间完成的，为Java提供了很好地扩展性，如：动态代理类的生成，JSP等。

大致上来讲，类加载过程可划分为：加载、连接、初始化。其中，连接又可以分为：校验、准备、解析。

![image-20200827212648620](C:\Users\92985\AppData\Roaming\Typora\typora-user-images\image-20200827212648620.png)

> 顺序问题：“解析”不一定按照顺序执行。同时，这些阶段按顺序“开始”，但不一定按顺序“进行”或“完成”。*【单例模式：双重检查】【对象逸出】*

1. 加载阶段，JVM需要通过类的全限定类名获取此类的二进制字节流，将其转换为方法区的运行时数据结构，并在内存中生成一个Class对象，作为方法区各个数据的访问入口。
2. 验证：确保加载的字节流中包含的信息符合规范。四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证（**发生在解析阶段**（顺序问题！））
3. 准备：为类中定义的变量**分配内存**并设置类变量**初始值**的阶段。（类变量会随着Class对象一起存放在Java堆中）
4. 解析：将常量池中的符号引用（字面量）替换为直接引用（指向目标的指针或句柄）的过程。
5. 初始化：执行类构造器<clinit>()的过程。

> <clinit>()方法是由编译器自动收集类中的**所有类变量的赋值动作和静态语句块(**static{}块)中的语句合并产生的。
>
> <clinit>()方法与类的构造函数不同，它不需要显示地调用父类构造器，Java虚拟机会保证子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>方法类型肯定是java.lang.Object。这也意味着父类定义的静态语句块要优先于子类的变量赋值操作。

#### 类加载器

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用远超类加载阶段。任意一个类都必须由加载它的类加载器和这个类本身一起确立其在Java虚拟机中的唯一性。

java的类加载架构包括：

- 三层类加载器
- 双亲委派机制（加载器间的层次关系）：如果一个类加载器收到了类加载请求，它首先不会自己尝试加载这个类，而是把这个请求委派个父类加载器去完成。

优势

- 类随着类加载器一起，具备了一种带有优先级的层次关系。保证了Java类型体系的一致性。
- 

### 你遇到过哪些OOM的情况？

理论上：

- 堆溢出：不断创建对象
- 虚拟机栈溢出：~~递归（StackOverFlow）~~
- 运行时常量池溢出：创建字符串并放入常量池中（String::intern()）
- 方法区溢出：运行时生成大量动态类（JSP，CGLIB字节码增强）
- 直接内存溢出：unsafe::allocateMemory()。

实际中：





### 垃圾标记算法？

- 引用计数算法：循环引用问题
- 可达性算法：通过一系列成为GC Roots的跟对象作为起始节点集，从这些节点开始，根据引用对象向下搜索。若某个对象和GC Roots之间没有任何引用连项链，即GC Roots到这个对象不可达时，则证明此对象时不可能再被使用的。

>固定可作为GC Roots的对象包括以下几种：
>
>- 在虚拟机栈（栈帧中的局部变量表）中引用的对象
>- 方法区中类静态属性引用的对象
>- 方法去中常量引用的对象
>- 本地方法栈中JNI引用的对象
>- JVM内部引用，如基本数据类型对应的Class对象，常驻的异常对象，系统类加载器
>- 同步锁持有的对象

### 垃圾回收算法？

分代算法。不同分区采用不同的垃圾回收算法：

- 标记-清除：最基础
- 标记-复制：（8:1:1的新生代）
- 标记-整理

> 标记-整理和标记-清除算法的本质差异在于前者是一种非移动式的回收算法。
>
> 如果移动存活对象，移动存活对象并更新所有引用这些对象的地方将会是极为负重的操作，且这种操作必须暂停所有的用户程序。“Stop the world“（长期）
>
> 如果不移动，空间碎片化问题就只能依赖更为复杂的内存分配器来解决。（短期）
>

关注吞吐量的Parallel收集器是基于标记-整理算法的

关注延迟的CMS收集器则是基于标记-清除算法的（暂时容忍，直到碎片化程度影响到对象分配，在使用标记-整理算法收集一次。

### 垃圾收集器：CMS

- CMS是一种以获取最短回收停段时间为目标的收集器。

- 基于标记-清除算法实现

- 其中初始标记、重新标记仍需要“stop the world"
- 在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作


![image-20200827203658687](https://raw.githubusercontent.com/YN-Zheng/img/master/typora202008/27/203700-867738.png)

### 垃圾收集器：G1

从G1开始，垃圾收集器的设计导向都从追求一次性将整个Java堆全部清理干净，转换为了能够应付应用的内存分配速率。在G1收集器出现前的所有其他收集器，包括CMS在内，垃圾手机的目标范围要么是整个新生代，要么整个老年代，要么就是整个Java堆。而G1可以**面向堆内存任何部分来组成回收集**进行回收。衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收效益最大，这就是G1收集器的Mixed GC模式。

基于Region的堆内存布局:G1不再坚持固定大小以及固定数量的分代区域划分,而是将连续的Java堆分成了多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代空间或者老年代空间。

故虽然G1仍然保留新生代和老年代的概念，但不再是固定的了，它们都是一系列区域的动态几何。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，每次根据用户设定允许的听顿时间，优先处理回收价值收益最大的Region。

![image-20200827203718926](https://raw.githubusercontent.com/YN-Zheng/img/master/typora202008/27/203725-700223.png)



相比CMS，G1的优势有：

1. 可以指定最大停顿时间
2. 标记-整理算法，利于程序的长时间运行

### JDK自带工具（指令）你知道哪些？

| 工具   |                                                              |
| ------ | ------------------------------------------------------------ |
| jps    | 和ps命令类似：列出正在运行的虚拟机进程                       |
| jstat  | 监视虚拟机各种运行状态信息：类加载、垃圾手机、运行期编译状况 |
| jstack | 生成虚拟机当前时刻的线程快照,来定位线程出现长时间停顿的原因：死锁、死循环、请求外部资源导致的长时间挂起 |





### JVM调优？







## JAVA集合

笼统的讲，JAVA集合可以分为三类：Set、List和Map。其中Set和List都继承自Collection类，用于存储单列元素。Map则是双列集合。

Set，即数学意义上的集合，无序，用于存储不重复的元素。常用的实现类有HashSet，TreeSet。这些实现类都是基于对应的Map实现的。其中key为元素，value为同一个Object类型的常量对象（PRESENT）

List，列表，用于保存有序数据。常用的实现类有ArrayList，LinkedList。线程安全的有Vector，CopyOnWriteArrayList

Map，映射表，用于实现从key到value的映射。常用的实现类有TreeMap，HashMap。线程安全的有ConcurrentHashMap，HashTable

Java同时也提供了Collections、Arrays这些工具类则为这些集合提供了排序、同步、洗牌等功能。但其同步功能只是相当于为所有方法加上synchronized关键字，不如使用专门的线程安全的工具类

### 讲一讲ArrayList扩容缩容吧

当调用ArrayList的add()方法时，若此时需要扩容，ArrayList会将原容量乘以1.5倍，生成新数组，并将原来的数组复制到新数组中。

- 复制所用的方法为Arrays.copy()方法，其中又调用了System.arraycopy()。这是一个native方法，相比自己循环复制会快一些
- 1.5倍是用移位＋加法算出来的

ArrayList在删除元素时不会主动缩容，而是需要用户自己调用trimToSize()方法。

（我们可以通过反射获取ArrayList中维护的elementData数组，来观察内部数组的容量到底是怎么变化的。）



### 讲一讲HashMap

- JDK7以前：数组+链表
- JDK8后：数组+链表 or 数组+ 红黑树
  - 8、6、64
- 

### ConcurrentHashMap



### 







## JAVA多线程